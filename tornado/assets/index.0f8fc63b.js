import{G as e,S as n,a as t,C as o,F as i,T as a,R as s,P as r,A as d,D as u,B as l,b as m,c,d as v,e as p,f,M as x,g as h,h as g,W as w,s as P,i as M,O as z,V as T,j as y}from"./vendor.128cf21d.js";!function(e=".",n="__import__"){try{self[n]=new Function("u","return import(u)")}catch(t){const o=new URL(e,location),i=e=>{URL.revokeObjectURL(e.src),e.remove()};self[n]=e=>new Promise(((t,a)=>{const s=new URL(e,o);if(self[n].moduleMap[s])return t(self[n].moduleMap[s]);const r=new Blob([`import * as m from '${s}';`,`${n}.moduleMap['${s}']=m;`],{type:"text/javascript"}),d=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(r),onerror(){a(new Error(`Failed to import: ${e}`)),i(d)},onload(){t(self[n].moduleMap[s]),i(d)}});document.head.appendChild(d)})),self[n].moduleMap={}}}("/assets/");let R,C,S,_,j,b,F,A,G,U,L,E;function H(){_.width=window.innerWidth,_.height=window.innerHeight,C.aspect=_.aspect,C.updateProjectionMatrix(),S.setSize(_.width,_.height),S.setPixelRatio(_.pixelRatio)}const D=new y;function O(){A.begin(),j.update();const e=D.getElapsedTime();b.uniforms.uTime.value=e,L.uniforms.uTime.value=e,U.uniforms.uTime.value=e,G.rotation.z=e/40,S.render(R,C),requestAnimationFrame(O),A.end()}!function(){const y=new e({width:300});A=new n,A.showPanel(0),document.body.appendChild(A.dom),_={width:window.innerWidth,height:window.innerHeight,get aspect(){return this.width/this.height},get pixelRatio(){return Math.min(window.devicePixelRatio,2)}},R=new t,R.background=new o(13426943),R.fog=new i(13426943,10,200);const D=new a,k=D.load("/assets/smoke_01.e8724c21.png"),I=D.load("/assets/GroundForest003_COL_VAR1_3K.3c7e134f.jpg");B(I);const K=D.load("/assets/GroundForest003_DISP_3K.56efde55.jpg");B(K);const N=D.load("/assets/GroundForest003_GLOSS_3K.18859091.jpg");B(N),B(D.load("/assets/GroundForest003_REFL_3K.8f36689f.jpg"));const W=D.load("/assets/GroundForest003_NRM_3K.83c0112a.jpg");B(W);const $=D.load("/assets/GroundForest003_AO_3K.a3540613.jpg");function B(e){e.wrapS=s,e.wrapT=s,e.repeat.set(16,16)}B($),C=new r(75,_.aspect,.01,1e3),C.position.z=50,C.position.y=5,R.add(C);const V=new d(16777215,.2);R.add(V);const q=new u(16777215,.3);R.add(q);const J={count:5e3,radius:5,height:60,curviness:7,range:2,particleSize:300,curvinessChangeRate:1},Q=new l,X=new Float32Array(3*J.count),Y=new Float32Array(J.count),Z=[4,6,8,10,12,14,16,32,48],ee=[1,2,4];for(let e=0;e<J.count;e++){const n=3*e,t=n+1,o=t+1,i=Math.random()*Math.PI*2,a=J.height*(e/J.count),s=(J.radius+.015*Math.max(0,e-.8*J.count))*(e/J.count);X[n]=Math.sin(i)*(s+Math.random()*s),X[t]=a,X[o]=Math.cos(i)*(s+Math.random()*s),Y[e]=ee[Math.floor(ee.length*Math.random())],e>.8*J.count&&(Y[e]=Z[Math.floor(Z.length*Math.random())])}Q.setAttribute("position",new m(X.reverse(),3)),Q.setAttribute("size",new m(Y.reverse(),1)),b=new c({depthWrite:!1,transparent:!0,side:v,uniforms:{uSize:{value:J.particleSize},uPixelRatio:{value:_.pixelRatio},uTime:{value:0},uSpeed:{value:5},uHeight:{value:J.height},uCurviness:{value:J.curviness},uCurvinessChangeRate:{value:J.curvinessChangeRate},uRange:{value:J.range},uTexture:{value:k}},vertexShader:"\n      attribute float size;\n\n      uniform float uSize;\n      uniform float uTime;\n      uniform float uSpeed;\n      uniform float uHeight;\n      uniform float uCurviness;\n      uniform float uCurvinessChangeRate;\n      uniform float uRange;\n      uniform float uPixelRatio;\n\n      varying vec4 vNormal;\n      varying vec2 vUv;\n\n      void main() {\n\n        vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n        float angle = atan(modelPosition.x, modelPosition.z);\n        float distanceToCenter = length(modelPosition.xz);\n        float speed = 1.0 - (modelPosition.y / uHeight);\n        modelPosition.x = sin(angle + uTime * speed * uSpeed) * distanceToCenter;\n        modelPosition.x = modelPosition.x + sin(uTime * uCurvinessChangeRate + (modelPosition.y / uCurviness)) * uRange;\n        modelPosition.z = cos(angle + uTime * speed * uSpeed) * distanceToCenter;\n        modelPosition.z = modelPosition.z + cos(uTime * uCurvinessChangeRate + (modelPosition.y / uCurviness)) * uRange;\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n\n        vNormal = vec4(normal, 1.0);\n        gl_Position = projectedPosition;\n        gl_PointSize = size * uSize * uPixelRatio;\n        gl_PointSize *= (1.0 / - viewPosition.z);\n      }\n    ",fragmentShader:"\n      varying vec4 vNormal;\n      uniform sampler2D uTexture;\n\n      void main() {\n        vec2 uv = (vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n        vec4 textureColor = texture2D(uTexture, uv);\n        gl_FragColor = textureColor;\n      }\n    "}),y.add(J,"count").min(100).max(1e6).step(100),y.add(J,"radius").min(1).max(100).step(.1),y.add(J,"height").min(1).max(100).step(.1),y.add(b.uniforms.uCurviness,"value").min(0).max(21).step(.1).name("curviness"),y.add(b.uniforms.uCurvinessChangeRate,"value").min(0).max(10).step(.001).name("curviness rate change"),y.add(b.uniforms.uRange,"value").min(0).max(10).step(.1).name("range"),y.add(b.uniforms.uSize,"value").min(1).max(5e3).step(.1).name("size"),y.add(b.uniforms.uSpeed,"value").min(1).max(100).step(.1).name("speed"),F=new p(Q,b),R.add(F);const ne=new l,te=500,oe=J.radius,ie=new Float32Array(1500),ae=new Float32Array(te),se=.1*J.height,re=[1,2,3,4];for(let e=0;e<te;e++){const n=3*e,t=n+1,o=t+1,i=Math.random()*Math.PI*2,a=se*(e/te),s=2+oe*(e/te);ie[n]=Math.sin(i)*(s+Math.random()*s),ie[t]=a,ie[o]=Math.cos(i)*(s+Math.random()*s),ae[e]=re[Math.floor(re.length*Math.random())]}ne.setAttribute("position",new m(ie.reverse(),3)),ne.setAttribute("size",new m(ae.reverse(),1)),L=new c({transparent:!0,side:v,uniforms:{uPixelRatio:{value:_.pixelRatio},uTime:{value:0},uSpeed:{value:2},uHeight:{value:se}},vertexShader:"\n      attribute float size;\n\n      uniform float uTime;\n      uniform float uSpeed;\n      uniform float uHeight;\n      uniform float uPixelRatio;\n\n      varying vec2 vUv;\n\n      void main() {\n\n        vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n        float angle = atan(modelPosition.x, modelPosition.z);\n        float distanceToCenter = length(modelPosition.xz);\n        float speed = 1.0 - (modelPosition.y / uHeight);\n        modelPosition.x = sin(angle + uTime * speed * uSpeed) * distanceToCenter;\n        modelPosition.x = modelPosition.x + sin(uTime );\n        modelPosition.z = cos(angle + uTime * speed * uSpeed) * distanceToCenter;\n        modelPosition.z = modelPosition.z + cos(uTime);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n\n        gl_Position = projectedPosition;\n        gl_PointSize = size * 20.0 * uPixelRatio;\n        gl_PointSize *= (1.0 / - viewPosition.z);\n      }\n    ",fragmentShader:"\n      void main() {\n        gl_FragColor = vec4(vec3(0.0), 1.0);\n      }\n    "}),E=new p(ne,L),R.add(E);const de=new f(500,500,1e3,1e3);de.setAttribute("uv2",new m(de.attributes.uv.array,2));const ue=new x({color:"#69b581",map:I,displacementMap:K,displacementScale:2,normalMap:W,roughnessMap:N,roughness:.5,aoMap:$,aoMapIntensity:1}),le=new h(de,ue);le.rotation.x=.5*-Math.PI,le.position.y=-1.5,R.add(le);const me=new f(1e3,1e3,1);U=new c({side:g,transparent:!0,uniforms:{uTime:{value:0}},vertexShader:"\n      uniform float uTime;\n      varying vec2 vUv;\n      varying float vTime;\n      void main() {\n        vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n        vUv = uv;\n        vTime = uTime;\n      }\n    ",fragmentShader:"\n    varying float vTime;\n    /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n    vec3 random3(vec3 c) {\n      float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n      vec3 r;\n      r.z = fract(512.0*j);\n      j *= .125;\n      r.x = fract(512.0*j);\n      j *= .125;\n      r.y = fract(512.0*j);\n      return r-0.5;\n    }\n\n    /* skew constants for 3d simplex functions */\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n\n    /* 3d simplex noise */\n    float simplex3d(vec3 p) {\n       /* 1. find current tetrahedron T and it's four vertices */\n       /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n       /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n       /* calculate s and x */\n       vec3 s = floor(p + dot(p, vec3(F3)));\n       vec3 x = p - s + dot(s, vec3(G3));\n\n       /* calculate i1 and i2 */\n       vec3 e = step(vec3(0.0), x - x.yzx);\n       vec3 i1 = e*(1.0 - e.zxy);\n       vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n       /* x1, x2, x3 */\n       vec3 x1 = x - i1 + G3;\n       vec3 x2 = x - i2 + 2.0*G3;\n       vec3 x3 = x - 1.0 + 3.0*G3;\n\n       /* 2. find four surflets and store them in d */\n       vec4 w, d;\n\n       /* calculate surflet weights */\n       w.x = dot(x, x);\n       w.y = dot(x1, x1);\n       w.z = dot(x2, x2);\n       w.w = dot(x3, x3);\n\n       /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n       w = max(0.6 - w, 0.0);\n\n       /* calculate surflet components */\n       d.x = dot(random3(s), x);\n       d.y = dot(random3(s + i1), x1);\n       d.z = dot(random3(s + i2), x2);\n       d.w = dot(random3(s + 1.0), x3);\n\n       /* multiply d by w^4 */\n       w *= w;\n       w *= w;\n       d *= w;\n\n       /* 3. return the sum of the four surflets */\n       return dot(d, vec4(52.0));\n    }\n\n    /* const matrices for 3d rotation */\n    const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\n    const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\n    const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n    float simplex3d_fractal(vec3 m) {\n      return 0.5333333*simplex3d(m*rot1 + vTime * 0.1)\n        +0.2666667*simplex3d(2.0*m*rot2)\n        +0.1333333*simplex3d(4.0*m*rot3 + vTime)\n        +0.0666667*simplex3d(8.0*m + vTime * 0.5);\n    }\n\n    varying vec2 vUv;\n\n    void main() {\n      vec2 p = vUv * 20.0;\n      vec3 p3 = vec3(p, 0.9);\n      float value = simplex3d_fractal(p3*8.0+8.0);\n      value = 0.5 + 0.5*value;\n      value *= smoothstep(0.0, 0.005, abs(0.6-p.x));\n      float dist = abs(distance(vUv * 2.0, vec2(1.0)));\n      gl_FragColor = vec4(vec3(value), 1.0 - dist);\n    }\n    "}),G=new h(me,U),G.rotation.x=.5*-Math.PI,G.position.y=J.height+5,R.add(G),S=new w({antialias:_.pixelRatio<1.5}),S.outputEncoding=P,S.toneMapping=M,S.toneMappingExposure=.5,S.setSize(_.width,_.height),S.setPixelRatio(_.pixelRatio),document.body.appendChild(S.domElement),j=new z(C,S.domElement),j.enableDamping=!0,j.screenSpacePanning=!1,j.minDistance=5,j.maxDistance=100,j.target=new T(0,20,0),window.addEventListener("resize",H),O()}();
